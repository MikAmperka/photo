## Девчёнкам нравятся Big Clocks

За время карантина многие наконец разобрали весь тот хлам, что хранился на балконах, антресолях и шкафах.
Так, я раскопал, непонятно от куда взявшуюся, зеленую светодиодную ленту и остатки картонных упаковок из Икеи.
Вот что из этого получилось.

![Main image](https://github.com/tolikivanov/photo/raw/master/main.jpg)
<cut />

Что подсвечивать зеленой лентой? Непонятно.
Зато, она отлично подойдёт для светодиодной индикации.

И тут первое, что приходит в голову - собрать семисигментный индикатор и сделать из этого всего Большие Часы.
Моего картона должно хватить на четыре 32 см индикатора. Не Биг Бэн, как у Королевы, но всё же.

## Что для этого понадобится
### Материалы:
-   Картон;
-   Светодиодная лента, 12 В;
-   Листы бумаги 80 г/м2;
-   Клей карандаш;
-   Провода;
-   Контроллер вроде Ардуино;
-   4 х Octofet (сборка из 8-ми MOSFET транзисторов);
-   Блок питания 12В;

### Инструменты:
-   Канцелярский нож;
-   Ножницы;
-   Кусачки;
-   Отвертка, шлицевая и крест;
-   Паяльник;
-   Провод USB;
-   Линейка;
-   Карандаш;

## Как собрать

Я как ниндзя разрезаю найденный картон канцелярским ножом.

![Cut body](https://github.com/tolikivanov/photo/raw/master/ninja-cut.gif)

На одну из сторон, теперь она будет тыльной, приклеил дополнительные "прямоугольнички" вырезанные из того же картона вдоль рёбер жесткости. Сквозь них пропущу провода.

![Add wire chanel](https://github.com/tolikivanov/photo/raw/master/Wire-chanel.jpg)

Для сегмента будущего индикатора отрезал 10 см отрезок светодиодной ленты и припаял к нему пару проводов. 

![Add wire](https://github.com/tolikivanov/photo/raw/master/led-wire.jpg)

Рассеивателем для отрезка ленты станет цилиндр, вырезанный и свёрнутый из обычных офисных листов А4, склеенных клеем карандашом. 

![Make cylinder](https://github.com/tolikivanov/photo/raw/master/cylinder.gif)

Бумага, картон. Получается очень эко-фрэндли. Мне нравится!

Теперь приклеим цилиндры к каркасу пропустив провода в отверстия.

![Join cylinder](https://github.com/tolikivanov/photo/raw/master/join-cylinder.jpg)

После того, как все цилиндры приклеены, можно заняться кабель-менеджментом и спрятать все провода внутрь заранее подготовленных каналов.

![Cable-management](https://github.com/tolikivanov/photo/raw/master/cable-management.gif)

Торцы цилинров закрыл заглушками вырезанными всё из того же картона.

![Add stub](https://github.com/tolikivanov/photo/raw/master/stub.jpg)

Тоже самое осталось провернуть ещё для 3-х цифр. Надеюсь успеть до конца карантина.

## Управление
### Проблема №1. Ток

Привычными индикаторами, каждый сегмент которых потребляет всего 20-30 мА мохно управлять напрямую контроллером. Например с входов-выходов популярной Atmega328P можно снять до 40 мА.

Один сегмент моего индикатора потребляет аж ххх мА. Для управления таким током, между пинами контроллера и каждым сегментом, дополнительно придется использовать транзисторы или реле, способные пропустить через себя ток в ххх мА.

--Фото транзистора и реле--

Реле шумно и громоздко, а силовые ключи на MOSFET транзисторах - кажется то, что нужно.

### Проблема №2. Контакты

Чтобы управлять одним индикатором понадобыться 7 выходов. Четыри индикатора - это уже 28, а ещё разделительная точка. Итого 29, а у Ардуино Уно выходов всего 20.

В готовых индикаторных сборках используют выходные сдвиговые регистры —  микросхемы для увеличения количества цифровых выходов. Он управляется тремя пинами, а на выходе даёт целых восемь. 

-- Фото индикатора с двух сторон --

### Проблема №3. Габариты

Учитывая всё вышесказанное - собираю схему на сдвиговом регистре и силовых ключах.

-- фото сборки на макетке --

И хоть я размахнулся с размер будущих часов, но собрать "такое" для каждого из 4-х индикаторов - это слишком.

### Решение

Гораздо более элегантным решением стал OctoFet - готовая сборка из сдвигового регистра и 8-ми полевиков, каждый из которых расчитан на напряжение до 30 вольт и может пропустить через себя до 3-х ампер. 

-- фото сборки на макетке и октофета --

## Подключение

Провода от каждого сегмента индикатора подключил к клеммникам выходов Octofet-а.

![Connect digit to Octofet](https://github.com/tolikivanov/photo/raw/master/Connection.png)

А сам Octofet, чтоб не болтался, закрепил на основании, которое я вырезал из той же картонки.

![Connect Octofet to digit](https://github.com/tolikivanov/photo/raw/master/connectOctofet.jpg)

Добавил блок питания и Ардуино.

![Connect Arduino to Octofet](https://github.com/tolikivanov/photo/raw/master/Arduino-Test-Connection.png)

## Прошивка

Программировать контроллер будем через [Arduino IDE](http://wiki.amperka.ru/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-arduino-ide).
Для работы с Octofet-ом и часами реального времени дополнительно скачал и установил пару библиотек. 

  - [Библиотека Octofet](https://github.com/amperka/AmperkaFet)
  - [Библиотека TroykaRTC](https://github.com/amperka/TroykaRTC)
  - [Как устанавливать библиотеки в Arduino IDE](http://wiki.amperka.ru/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5:%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8)

В зависимости от состояния транзисторов в сборке - на индикаторе будут отображаться необходимые цифры. 

![Bitmap](https://github.com/tolikivanov/photo/raw/master/bitmap.gif)

Загрузил тестовый пример в Ардуино.

```cpp
// библиотека для работы с модулями по интрефейсу SPI
#include <SPI.h>
// библиотека для работы со сборкой силовых ключей
#include <AmperkaFET.h>
// пин выбора устройства на шине SPI
#define PIN_CS  7

// кол-во сегментов в индикаторе
#define SEGMENT_COUNT       8
 
// префикс «0b» означает, что целое число за ним записано в
// в двоичном коде. Единицами мы обозначим номера сегментов
// индикатора, которые должны быть включены для отображения
// арабской цифры. Всего цифр 10, поэтому в массиве 10 чисел.
// Нам достаточно всего байта (англ. byte, 8 бит) для хранения
// комбинации сегментов для каждой из цифр.
byte numberSegments[10] = {
  0b11101110, 0b00100100, 0b11110010, 0b10110110, 0b00111100,
  0b10011110, 0b11011110, 0b00100110, 0b11111110, 0b10111110,
};

// создаём объект mosfet для работы со сборкой силовых ключей
// передаём номер пина выбора устройства на шине SPI
FET mosfet(PIN_CS);
 
void setup()
{
  // начало работы с силовыми ключами
  mosfet.begin();
}
 
void loop()
{
  // определяем число, которое собираемся отображать. Пусть им
  // будет номер текущей секунды, зацикленный на десятке
  int number = (millis() / 1000) % 10;
  // получаем код, в котором зашифрована арабская цифра
  int mask = numberSegments[number];
  // для каждого из 7 сегментов индикатора...
  for (int i = 0; i < SEGMENT_COUNT; ++i) {
    // ...определяем: должен ли он быть включён. Для этого
    // считываем бит (англ. read bit), соответствующий текущему
    // сегменту «i». Истина — он установлен (1), ложь — нет (0)
    boolean enableSegment = bitRead(mask, i);
    // включаем/выключаем сегмент на основе полученного значения
    mosfet.digitalWrite(i, enableSegment);
  }
}
```

![Single gigit show](https://github.com/tolikivanov/photo/raw/master/singleDigit.gif)

Теперь можно соединить оставшиеся индикаторы в одну цепочку, добавить модуль часов реального времени и разделительный сегмент в виде точки.

![Full Schem](https://github.com/tolikivanov/photo/raw/master/fullSchem.png)

### Исходный код

Контроллер прошьем прошивкой отображающей текущее время на часах.

```cpp
// библиотека для работы с модулями по интерфейсу SPI
#include <SPI.h>
// библиотека для работы I²C
#include <Wire.h>
// библиотека для работы со сборкой силовых ключей
#include <AmperkaFET.h>
// библиотека для работы с часами реального времени
#include <TroykaRTC.h>

// пин выбора сборки устройств на шине SPI
#define PIN_CS  2
 
// префикс «0b» означает, что целое число за ним записано в
// в двоичном коде. Единицами мы обозначим номера сегментов
// индикатора, которые должны быть включены для отображения
// арабской цифры. Всего цифр 10, поэтому в массиве 10 чисел.
// Нам достаточно всего байта (англ. byte, 8 бит) для хранения
// комбинации сегментов для каждой из цифр.
byte numberSegments[10] = {
  0b11101110, 0b00100100, 0b11110010, 0b10110110, 0b00111100,
  0b10011110, 0b11011110, 0b00100110, 0b11111110, 0b10111110,
};
 
// создаём объект mosfet для работы со сборкой силовых ключей
// передаём номер пина выбора устройств на шине SPI
// и количество устройств подключённых в цепочке
FET mosfet(PIN_CS, 4);

// создаём объект для работы с часами реального времени
RTC clock;

void setup() {
   Serial.begin(9600);
  // начало работы с силовыми ключами
  mosfet.begin();
    // инициализация часов
  clock.begin();
  // метод установки времени и даты в модуль вручную
  // clock.set(10,25,45,27,07,2005,THURSDAY);    
  // метод установки времени и даты автоматически при компиляции
  clock.set(__TIMESTAMP__);
}

void loop() {
  // запрашиваем данные с часов  
  clock.read();

  // делим минуты и часы на разряды и отображаем на индикаторах
  showDigit (0, clock.getHour() / 10);
  showDigit (1, clock.getHour() % 10);
  showDigit (2, clock.getMinute() / 10);
  showDigit (3, clock.getMinute() % 10); 

  // мигаем разделителем
  mosfet.digitalWrite(1, 0, HIGH);  
  delay(1000);
  mosfet.digitalWrite(1, 0, LOW);
  delay(1000);
}

void showDigit (int module, int digit ){
  // получаем код, в котором зашифрована арабская цифра
  int mask = numberSegments[digit];
  // для каждого из 7 сегментов индикатора...
      for (int i = 0; i < 8; ++i) {
    // ...определяем: должен ли он быть включён. Для этого
    // считываем бит (англ. read bit), соответствующий текущему
    // сегменту «i». Истина — он установлен (1), ложь — нет (0)
    boolean enableSegment = bitRead(mask, i);
    // включаем/выключаем сегмент на основе полученного значения
    mosfet.digitalWrite(module, i, enableSegment);
  }
}
```

> Чтобы после установки время считывалось с модуля RTC -
> закоментируйте оба метода `clock.set()` и загрузите код снова;

-- Гифка рабочих часов --
